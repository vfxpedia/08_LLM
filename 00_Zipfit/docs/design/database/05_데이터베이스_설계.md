# 05. 데이터베이스 설계

## 5.1 개요

ZIPFIT은 RDB(PostgreSQL)와 Vector DB(pgvector)를 함께 사용합니다.

- **RDB**: 구조화된 메타데이터 (빠른 필터링, 정렬)
- **Vector DB**: 비정형 문서 임베딩 (의미 기반 검색)

---

## 5.2 RDB 스키마

### 5.2.1 공고 메타데이터 테이블

**[논의 필요]**

테이블명: `announcements`

```sql
CREATE TABLE announcements (
    -- 기본 키
    id VARCHAR(50) PRIMARY KEY,  -- 예: LH_lease_1

    -- 기관 정보
    provider VARCHAR(10) NOT NULL,  -- LH, SH, GH

    -- 공고 기본 정보
    announcement_type VARCHAR(50),  -- 국민임대, 행복주택 등
    title TEXT NOT NULL,
    region VARCHAR(100),

    -- 날짜 정보
    post_date DATE,
    deadline DATE,
    status VARCHAR(20),  -- 접수중, 접수마감 등

    -- 주택 정보
    deposit INTEGER,  -- 보증금 (만원)
    monthly_rent INTEGER,  -- 월세 (만원)
    area_type VARCHAR(50),  -- 전용면적 (예: 16m², 26m²)
    total_units INTEGER,  -- 총 세대수
    move_in_date VARCHAR(50),  -- 입주예정일

    -- 링크
    url TEXT,
    pdf_url TEXT,

    -- 메타 정보
    view_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_announcements_provider ON announcements(provider);
CREATE INDEX idx_announcements_region ON announcements(region);
CREATE INDEX idx_announcements_deadline ON announcements(deadline);
CREATE INDEX idx_announcements_status ON announcements(status);
```

**[사용자 논의 사항]**:
1. LH, SH, GH 통합 스키마가 적절한가?
2. 추가 필요한 컬럼은?
3. 인덱스 추가 필요 컬럼은?

---

### 5.2.2 사용자 정보 테이블

**[논의 필요]**

테이블명: `users`

```sql
CREATE TABLE users (
    -- 기본 키
    user_id VARCHAR(50) PRIMARY KEY,

    -- 개인 정보
    name VARCHAR(100),
    age INTEGER,
    residence VARCHAR(100),  -- 거주지
    residence_duration INTEGER,  -- 거주 기간 (년)

    -- 가족 정보
    marital_status VARCHAR(20),  -- single, married, other
    has_children BOOLEAN DEFAULT FALSE,
    number_of_children INTEGER,

    -- 경제 정보
    income INTEGER,  -- 월소득 (만원)

    -- 메타 정보
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**[사용자 논의 사항]**:
1. 로그인 기능 필요? (향후)
2. 개인정보 암호화 필요?
3. 추가 정보 수집 필요?

---

### 5.2.3 즐겨찾기 테이블

**[논의 필요]**

테이블명: `favorites`

```sql
CREATE TABLE favorites (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) REFERENCES users(user_id),
    announcement_id VARCHAR(50) REFERENCES announcements(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(user_id, announcement_id)
);

-- 인덱스
CREATE INDEX idx_favorites_user_id ON favorites(user_id);
```

---

### 5.2.4 비교 목록 테이블

**[논의 필요]**

테이블명: `comparisons`

```sql
CREATE TABLE comparisons (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) REFERENCES users(user_id),
    announcement_id VARCHAR(50) REFERENCES announcements(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(user_id, announcement_id)
);

-- 인덱스
CREATE INDEX idx_comparisons_user_id ON comparisons(user_id);
```

---

## 5.3 Vector DB 구조

### 5.3.1 공고 문서 임베딩

**[논의 필요]**

테이블명: `announcement_embeddings`

```sql
-- pgvector 확장 활성화
CREATE EXTENSION vector;

CREATE TABLE announcement_embeddings (
    id SERIAL PRIMARY KEY,
    announcement_id VARCHAR(50) REFERENCES announcements(id),

    -- 문서 정보
    document_name TEXT,
    page_number INTEGER,
    chunk_text TEXT,  -- 원본 텍스트 (검증용)

    -- 임베딩 (차원수는 모델에 따라 다름)
    embedding vector(768),  -- 예: 768차원 (sentence-transformers)

    -- 메타 정보
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 벡터 인덱스 (HNSW 알고리즘)
CREATE INDEX idx_announcement_embeddings_vector
ON announcement_embeddings
USING hnsw (embedding vector_cosine_ops);
```

**[사용자 논의 사항]**:
1. 임베딩 모델 선정 (차원수)
2. 청크 크기 (몇 자씩 나눌 것인가)
3. 인덱스 알고리즘 (HNSW vs IVFFlat)

---

### 5.3.2 Glossary 임베딩

**[논의 필요]**

테이블명: `glossary_embeddings`

```sql
CREATE TABLE glossary_embeddings (
    id VARCHAR(50) PRIMARY KEY,  -- 예: CI_001

    -- 용어 정보
    term VARCHAR(200) NOT NULL,
    category VARCHAR(100),
    definition_easy TEXT,
    definition_full TEXT,
    usage TEXT,
    example TEXT,
    related_terms TEXT[],  -- 배열
    source VARCHAR(200),
    major_category VARCHAR(100),
    tags TEXT[],  -- 배열

    -- 임베딩
    embedding vector(768),

    -- 메타 정보
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 벡터 인덱스
CREATE INDEX idx_glossary_embeddings_vector
ON glossary_embeddings
USING hnsw (embedding vector_cosine_ops);

-- 텍스트 검색 인덱스
CREATE INDEX idx_glossary_term ON glossary_embeddings(term);
```

---

## 5.4 데이터 통합 규격

### 5.4.1 LH/SH/GH 통합 스키마

**[논의 필요]**

문제점:
- 각 기관마다 공고 형식이 다름
- 필드명이 다름
- 데이터 형식이 다름

해결책:
1. **정규화 ETL 프로세스**
   - 각 기관 데이터를 통일된 형식으로 변환
   - 예: "게시일" vs "공고일" → "post_date"

2. **공통 필드 정의**
   - 모든 기관에 공통적으로 있는 필드
   - 예: 제목, 지역, 게시일, 마감일

3. **선택 필드 처리**
   - 일부 기관에만 있는 필드
   - NULL 허용 또는 JSON 컬럼 활용

**통합 매핑 예시**:

```
LH:
- 공고명 → title
- 지역 → region
- 게시일 → post_date
- 마감일 → deadline

SH:
- 제목 → title
- 공고지역 → region
- 공고시작일 → post_date
- 공고종료일 → deadline

GH:
- 공고명 → title
- 모집지역 → region
- 게시일자 → post_date
- 서류접수종료일 → deadline
```

---

## 5.5 데이터 마이그레이션

### 5.5.1 CSV → PostgreSQL

**[논의 필요]**

스크립트 예시:
```python
import pandas as pd
import psycopg2

# CSV 읽기
df = pd.read_csv('lh_lease_notices_eng.csv')

# PostgreSQL 연결
conn = psycopg2.connect(
    host="localhost",
    port="5432",
    database="zf_db",
    user="zf_admin",
    password="..."
)

# 데이터 삽입
for _, row in df.iterrows():
    cur.execute("""
        INSERT INTO announcements (id, provider, title, region, ...)
        VALUES (%s, %s, %s, %s, ...)
    """, (row['ID'], 'LH', row['공고명'], row['지역'], ...))

conn.commit()
```

### 5.5.2 PDF → Vector DB

**[논의 필요]**

프로세스:
1. PDF → Markdown 변환 (완료)
2. Markdown 청킹 (문장/문단 단위)
3. 임베딩 생성 (Sentence-Transformers)
4. Vector DB 저장

---

## 5.6 쿼리 예시

### 5.6.1 공고 검색

```sql
-- 서울 지역 행복주택, 접수 중
SELECT * FROM announcements
WHERE region LIKE '서울%'
AND announcement_type LIKE '%행복주택%'
AND status = '접수중'
ORDER BY deadline ASC;
```

### 5.6.2 벡터 유사도 검색

```sql
-- "행복주택 자격 조건" 질문에 대한 유사 문서 검색
SELECT
    announcement_id,
    document_name,
    page_number,
    chunk_text,
    embedding <=> %s::vector AS distance
FROM announcement_embeddings
ORDER BY distance ASC
LIMIT 5;
```

---

**작성일**: 2025년 11월 21일

**작성자**: 오흥재

**상태**: 초안 (사용자 논의 필요)
